我们开始啦

1. github上创建项目

   (1) .gitignore 指的是上传的时候不需要把哪些上传上去，比如build,node_modules等
   (2)  README.md github上项目的介绍

2. 空项目  npm init 一下，创建一个npm的项目

3. .editorconfig 文件，是统一代码风格

4. ESLint 用于js代码检查
------------------------------------

1.npm init

2.安装react
  npm install react --save

3.安装webpack
  npm install webpack --save

4.创建一个webpack.client.js文件
  配置entry 和 output

5.创建一个App.jsx  和 entry.js
  App.jsx是整个react代码的入口
  entry.js是用reactdom把react代码渲染到dom上的

6.继续配置webpack.config.js
  配置让react中的.jsx .js文件语法能让浏览器识别
  babel-loader 而babel-loader是开发时的工具，所以放在 -D
  module:{
      rules:[
         {
                test: /\.(js|jsx)?$/,
                exclude: /node_modules/,
                loader: "babel-loader"
              },
      ]
    }
  同时还需要安装babel-core核心库，因为babel-loader是一个插件，并不包含babel的核心代码
  再同时，创建.babelrc文件，里面是一个对象，因为babel默认只编译es6的语法，jsx无法编译，所以需要在这里写babel编译的规则
  也需要安装特定的preset
  npm install @babel/preset-react --D
  npm install @babel/preset-stage-0 -D
  npm install @babel/preset-env -D
  但是配置上babel7去掉了preset-stage-0，先安装吧

7. html-webpack-plugin的作用
   首先会生成一个html,同时将 entry 和 output 中的内容及规则注入到这个html中
   npm install html-webpack-plugin -D
   webpack再配置下


8. 开始服务端
   react-dom中的render方法提供了我们react客户端渲染的方法
   react-dom/server提供了我们服务端渲染的方法

   新建webpack.server.js配置文件

   const path = require('path');
   const nodeExternals = require('webpack-node-externals');

   module.exports = {
     target:'node',
     mode:'development',
     entry:{
       server: path.resolve(__dirname,'./src/entryserver.js')
     },
     output:{
       filename:'entryserver.js',
       path:path.resolve(__dirname, 'builds'),
       publicPath:'',
       libraryTarget:'commonjs2'
     },
     externals:[nodeExternals()],
     module:{
       rules:[
         {
           test: /\.js?$/,
           exclude: /node_modules/,
           loader: "babel-loader"
         },
         {
           test: /\.jsx?$/,
           exclude: /node_modules/,
           loader: "babel-loader"
         }
       ]
     }
   }

9. package.json里面需要一个build下先删除原先的，再打包的命令
   需要安装 npm install rimraf -D

10.新建server.js,用express
   npm install express --save

11.用react-dom/server提供的renderToString方法，ReactSSR.renderToString(serverDoor);


12.但是需要在外边也加一个html套
   新建template.html

   修改客户端
   1.entry,body改为root
   2.htmlplugin 里面传一个配置

   修改服务端
   将template.html读进来到node
   用node的fs模块和path模块
   const template = fs.readFileSync(path.resolve(__dirname,'../template.html'),'utf-8');
   注意，这里utf-8别忘记了，不然读取出来的是node的buffer格式


13.增加几个常用配置

   cross-env  /  webpack dev server  ／  hot module replacement

  1).window,linux,mac 设置环境变量是有区别的，所以需要安装第三方cross-env来帮我们处理
  npm install cross-env -D
  使用是在package.json中
   cross-env NODE_ENV=development

  2).安装webpack-dev-server，作用：可以使用webpack的配置去启动生成服务器，有文件变化就会去自动执行编译过程
  npm install webpack-dev-server -D

  if(isDev){
    config.devServer = {
      host:'0.0.0.0',    //可以访问到ip 和 localhost
      port:'8888',       //端口号
      contentBase:path.resolve(__dirname, 'build'),  //这个配置跟output输出一致即可
      hot:true,          //启动 hot module replacement
      overlay:{          //当出现errors错误的时候，在网页上弹出一层黑色背景及错误信息
        errors:true,
      },
      publicPath:'/public',  //前面设置了public，这里也需要加上
      historyApiFallback:{   //同理，index.html也需要加上这个
        index:'/public/index.html',
      }
    }
  }

  这里需要注意一点，就是webpack-dev-server，当build下有文件时候，会自动去这里读取同名文件，所以你感觉不生效，删除build即可


  3).hot module replacement,作用：页面上改动任何代码，我们可以看到页面上无刷新的展示出我们变更的效果
    1.安装 react-hot-loader
    npm install react-hot-loader@next -D

    2.需要在devServer设置
    hot:true,
    config.plugins.push(new webpack.HotModuleReplacementPlugin())

    还要修改entry，加入'react-hot-loader/patch',
    config.entry = {
        client: [
          'react-hot-loader/patch',
          path.resolve(__dirname,'./src/client/entry.js')
        ]
      }

    3.需要在.babelrc加入这个配置
    "plugins": ["react-hot-loader/babel"]

    4.客户端entry.js中添加代码
    if(module.hot){
      module.hot.accept('./../App.jsx',()=>{
        const NextApp = require('./../App.jsx').default;
        render(NextApp);
      })
    }

14.开始使用eslint 和 editorconfig

  继承extends ／  parser，用babel-eslint来检验编译的  ／  airbnb有些依赖等等

  1.配置.eslintrc 外和内文件
  npm install
  babel-eslint
  eslint-config-airbnb
  eslint-config-standard
  eslint-loader
  eslint-plugin-import
  eslint-plugin-jsx-a11y
  eslint-plugin-node
  eslint-plugin-promise
  eslint-plugin-react
  eslint-plugin-standard -D

  2.增加webpack的配置
  {
    enforce: "pre",
    test: /\.(js|jsx)?$/,
    exclude: /node_modules/,
    loader: "eslint-loader"
  },

  3.使用git commit之前一定要通过eslint检测，才能提交
    首先项目变成git项目
    git init
    接着用第三方工具 hasky
    npm install hasky -D
    最后在package.json里面添加命令
    "lint": "eslint --ext .js --ext .jsx build/",
    "precommit": "npm run lint",这个是git commit上传时的钩子，会先进行这个命令，没问题才执行git commit

15. 配置webpack-merge,提取公共配置


16. 服务端 dev-static.js
    配置服务端开发环境下的同构处理
    1.获取html的template
    2.获取webpack打包之后的bundle.js
    因为服务端开发环境下是不存在build下文件的
    我们就需要获取模版，所以用axios（客户端、服务端都可以使用），通过http请求获取template的HTML模版
    安装 axios
    npm install axios -S
    因为需要获取的是webpack打包之后的bundle.js，但是读取到这个文件不能写在磁盘上，因为很慢，所以需要用到一个
    memory-fs的第三方，来把bundle.js放到内存中读取，快
    npm install memory-fs -D

